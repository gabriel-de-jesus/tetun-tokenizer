from typing import List, Callable
from pathlib import Path


class Evaluation:
    """ 
    A class used for evaluating the accuracy of a tokenizer. It provides functionality 
    for visualizing the unmatched tokens. 
    """

    def __init__(self, input_text_file: Path, human_tokens_file: Path, tokenizer: Callable) -> None:
        self.input_text_file = input_text_file
        self.human_tokens_file = human_tokens_file
        self.tokenizer = tokenizer

    def load_data(self, file_path: Path, human_input=True) -> List[str]:
        """
        Load data from:
        1. Human tokes (ground truth), where it contains each tokens per line.
        2. Input file to be tokenize by the tokenizer (human_input=False).

        :param file_path: a path of the input file to read.
        :param human_input: True if it reads the human_tokens file, False otherwise.
        """
        try:
            with file_path.open('r', encoding='utf-8') as f_load:
                if human_input:
                    contents = [line.strip() for line in f_load.readlines()]
                else:
                    contents = " ".join(f_load.readlines())
        except FileNotFoundError:
            print(f"File not found at: {file_path} ")
            return []
        except UnicodeEncodeError:
            print(f"Can not decode file at: {file_path}")
        return contents

    def tokenizer_tokens(self) -> List[str]:
        """ Read and tokenize the input file. """
        input_text = self.load_data(self.input_text_file, human_input=False)
        # Choose a tokenizer to tokenize the input text
        tokens = self.tokenizer.tokenize(input_text)
        return tokens

    def human_tokens(self):
        """ Read the file contained human tokens (ground truth) data. """
        tokens = self.load_data(self.human_tokens_file)
        return tokens

    def get_total_elements(self) -> int:
        """ Compare the lists length of the tokenizer and humans. If they are different, get the minimum one. """
        if len(self.tokenizer_tokens()) != len(self.human_tokens()):
            total_elements = min(len(self.tokenizer_tokens()),
                                 len(self.human_tokens()))
        else:
            total_elements = len(self.tokenizer_tokens())
        return total_elements

    def calcualte_accuracy(self) -> float:
        """ Calculate the accuracy of tokens generated by the tokenizer. """
        matching_elements = sum(1 for i in range(
            self.get_total_elements()) if self.tokenizer_tokens()[i] == self.human_tokens()[i])
        accuracy = (matching_elements / self.get_total_elements()) * 100
        accuracy = print(f"The tokenizer accuracy is: {accuracy:.2f}%.")
        return accuracy

    def visualize_error(self) -> None:
        """ Visualize unmatch tokens. """
        unequal_tokens = []
        for i in range(self.get_total_elements()):
            if self.tokenizer_tokens()[i] != self.human_tokens()[i]:
                unequal_tokens.append(
                    (self.tokenizer_tokens()[i], self.human_tokens()[i]))

        if len(unequal_tokens) > 0:
            print(f"\nThe following tokens are not matched: ")
            for token in unequal_tokens:
                print(
                    f"\tToken '{token[0]}' in tokenizer_tokens and '{token[1]}' in human_tokens.")

    def evaluate(self) -> None:
        """ Calcualte accuracy and visualize error. """
        print("\n============================")
        if self.tokenizer_tokens() != self.human_tokens():
            print(
                "The token lists generated by the tokenizer and the human input are of different lengths!")

        self.calcualte_accuracy()
        self.visualize_error()

        print("============================\n")
